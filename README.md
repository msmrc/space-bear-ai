# space-bear-ai

### Алгоритм семантического подбора

Взят корпус текста в виде эмбеддингов из русскоязычной Википедии. Он доступен как компонента библиотеки Fasttext.
По стандарту эмбеддинги доступны с размерностью 300. Чтобы уместить в более легковесное приложение - упаковали в меньшую размерность 50.
Эмбеддинги используем как источник семантического вектора - вычисляем средний эмбеддинг всех описаний объектов. 

Похожесть объектов между собой как первичный вариант - косинусное расстояние между осредненными векторами эмбеддингов.
Для стартового unsupervised решения подходит.

Инновационность проекта в данном случае тоже определяется семантикой, сейчас используется заданный набор слов, 
который можно варьировать как угодно, чтобы понять какие выдачи хочется получать.

Как можно улучшить - собрать датасет для рекомендательных систем по типу QQP  датасета, тогда можно будет запускать более совершенные
supervised подходы, например, LambdaMART. В качестве метрики можно использовать NDCG, YetiRank.

### Описание структуры кода и как запустить веб-сервис

Проект разделен на две обязательные части и одну необязательную:
- app - непосредственно описание веб сервиса с логикой вызова внутренних методов
- utils - содержит все функции обеспечивающие работу логики веб сервиса
- nbs - содержит .ipynb тетрадку для тестов

В procfile размещена команда для поднятия сервера на heroku или любом другом облачном сервисе, для локального запуска необходмимо поставить python, pip. 

Запустить команду 

```pip install -r requirements.txt ```

находясь в папке проекта. После этого запустить команду 

```gunicorn wsgi:main ```

В консоли будет что-то похожее, не должно зависеть от вида операционной системы

```
[2022-11-05 04:00:37 +0300] [55927] [INFO] Starting gunicorn 20.1.0
[2022-11-05 04:00:37 +0300] [55927] [INFO] Listening at: http://127.0.0.1:8000 (55927)
[2022-11-05 04:00:37 +0300] [55927] [INFO] Using worker: sync
[2022-11-05 04:00:37 +0300] [55939] [INFO] Booting worker with pid: 55939 
```

После этого необходимо подождать секунд 10-15, чтобы вебсервис смог подтянуть файл с эмбеддингами с облачного хранилища. 
Время может варьироваться в зависимости от пропускной скорости вашей сети.


### Описание методов

Вызов описания пользователя с выбранным id:

```get_user(id: str) -> Dict[str, Any]:```

Вызов списка всех пользователей:

```get_all_users() -> List[Dict[str, Any]]:```

Вызов проекта с выбранным id:

```get_project(id: str) -> Dict[str, Any]:```

Вызов списка всех проектов:

```get_all_projects() -> List[Dict[str, Any]]:```

Определение инновационности проекта:

```innovation_score_project(project_id: str, input_df: pd.DataFrame) -> bool:```

Реализация метрики Intersection Over Union:

```iou_metric(input_feats_1: List[Any], input_feats_2: List[Any]) -> float:```

Реализация метрики Intersection:

```intersection_metric(input_feats_1: List[Any], input_feats_2: List[Any]) -> float:```

Функция поиска похожих проектов:

```search_similar_projects(input_id: str, input_df: pd.DataFrame) -> Dict[int, float]:```

Функция поиска специалистов для проекта:

```search_specialists_for_project(project_id: str, input_df: pd.DataFrame) -> Dict[int, Dict[str, float]]:```

Функция поиска проектов для специалиста:

```search_projects_for_specialist(user_id: str, input_df: pd.DataFrame) -> Dict[int, Dict[str, float]]:```

Функция поиска пользователей для пользователя по интересам:

```search_users_for_user(user_id: str, input_df: pd.DataFrame) -> Dict[int, Dict[str, float]]:```

Функция вычисляющий косинусное расстояние:

```cosine_similarity(vec1: np.ndarray, vec2: np.ndarray) -> float:```

Функция получающий эмбеддинг для данной строки:

```embedd_representation(input_str: str, embeddings_df: pd.DataFrame) -> np.ndarray:```

Функция для получения текстового описания проекта:

```get_project_text_desc(id: str) -> str:```

Функция для получения текстового описания пользователя:

```def get_user_text_desc(id: str) -> str:```

Функция для получения навыков пользователя:

```def get_user_skill_desc(id: str) -> List[str]:```

Функция для получения ролей пользователя:

```def get_user_roles_desc(id: str) -> List[str]:```






